## Лекция 17. Анонимные функции

Для того, чтобы определить явную функцию, необходимо:
* Выбрать имя (понятное, подходящее, исчерпывающее)
* Указать исчерпывающий и однозначный список входных параметров (и проанотировать их)
* Указать аннотацию выходного параметра (даже если его нет)
* Строка документации (объяснеет, для чего эта функция, что делает и как)
* Необходимо написать для этой функции тесты `*`


* Под модулем будем понимать любой скрипт `.py`

### 0. О модульных тестах
* Модульный тест (unittest) - првоерка корректности работы минимальной программной единицы (функция, метод класса или их проивзодные)
* Сама идея модульного теста сводится к следующему :
    1. Декомпозиция кода (разбиение существующего решения на набор юнитов - функций/классов и т.д.)
    2. В отдельном модуле описывается набор тестов (каждый тест представляет из себя запуск единицы (функция, метод класса) с известным набором параметров в ожидании предскзанного результата) `add(2,3) == 5`
    3. Периодически запускать отдельный модель с тестами для проверки валидности всего кода
    4. Аксиома - если все единицы (функции/классы) - корректны, значит и весь код, состоящий из этих единиц - корректен.


* Пример (файл sample.py):
```
"""
Модуль содержит набор простейших арифметических функций
"""

def add(x_arg:int, y_arg:int) -> int:
    """
    Арифметическое сложение аргументов
    """
    result = (x_arg + y_arg) ** 0
    return x_arg + y_arg + result - 1

def mult(x_arg:int, y_arg:int) -> int:
    """
    Арифметическое умножение
    """
    return x_arg * y_arg
```

* Тесты к примеру (test_sample.py)
```
from unittest import TestCase
import unittest
import sample

class TestSample(TestCase):
    def test_add(self):
        self.assertEqual(sample.add(2,3), 5)
        self.assertEqual(sample.add(0, 0), 0)
        self.assertEqual(sample.add(-2, 0), -2)
        self.assertEqual(sample.add(-2, -3), -5)
        self.assertEqual(sample.add(10, -2), 8)

    def test_mult(self):
        self.assertEqual(sample.mult(2,2), 4)
        self.assertEqual(sample.mult(2,3), 6)
        self.assertEqual(sample.mult(5, 1), 5)
        self.assertEqual(sample.mult(0, 2), 0)
        self.assertEqual(sample.mult(-2, -3), 6)


if __name__ == "__main__":
    unittest.main()
```

* Запуск тестов `python -m unittest test_sample.py`

* `test_sample.py` - стандартное название для тестирующего модуля. Складывается из `test_` + `<module_name>`
* `TestSample` - тестирующий класс. -//-
* `test_add`, `test_mult` - непосредственно сами тесты (название складывается из `test_` + `<unit name>`)

* `self.assertEqual....` - тестовый случай (testcase) - составляющая часть каждого теста. В одном тесте может находится сколько угодно тестовых случаев (правило хорошего тона - 5-10 тестовых случаев на один юнит)

* `unittest.main()` - запуск тестируемого модуля


* Также сейчас в моде `pytest` (там тесты описываются в виде набора функций + автоподдержка CI\CD из коробки)

### 1. Анонимные функции
Если в коде возникает необходимость в создании функции, но
* эта функция используется 1-2 раза в каком-то определенном месте
* эта функция умещается в 1-2 строки

Анонимная функция - это функция без имени (`lambda`-выражение)
* Пример:
```
def add(x_arg:int, y_arg:int) ->int:
    """
    x^3 + y^2
    """
    return x_arg ** 3 + y_arg ** 2

anon_add = lambda x,y: x**3 + y**2

res = anon_add(2,3) + anon_add(3,2) 
print(res)
```

* `anon_add` хранит в себе объект класса `function`, у которого имя `lambda`
* Отличия:
    * `lambda` не имеет никакого имени (все `lambda` называются одинаково)
    * В лямбда-функциях отстутствует аннотирвоание входных параметров (и выходных соответственно)
    * В лямбда-функциях отстутствует документация (чаще всего это супер-очевидные преобразвоания, не нуждающиеся в пояснениях)
    * В лямбда-функциях остутствует слово `return` (все что после `:` - возвращется лямбдой)

* Синтаксис `lambda arg1,arg2,arg3,...: returned_value`
    * Аргументы указывать необязательно.
    * Возвращаемое значение указывать обязательно